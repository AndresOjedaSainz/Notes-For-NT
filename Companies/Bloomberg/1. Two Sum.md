# 1. Two Sum
## Difficulty - Easy

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

`Input: nums = [2,7,11,15], target = 9`

`Output: [0,1]`

Explanation: Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.

Example 2:

`Input: nums = [3,2,4], target = 6`

`Output: [1,2]`

Example 3:

`Input: nums = [3,3], target = 6`

`Output: [0,1]`

Follow-up: Can you come up with an algorithm that is less than **O(n2)** time complexity?

# Code Solution:
```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        indices = {} #val -> index

        for i, n in enumerate(nums):
            indices[n] = i
        
        for i,n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]
        
        return []

```
# Hash Map (Two Pass)
### Intuition
We can use a hash map to store the value and index of each element in the array. Then, we can iterate through the array and check if the complement of the current element exists in the hash map. The complement must be at a different index, because we can't use the same element twice.

By using a hashmap, we can achieve a time complexity of **O(n)** because the insertion and lookup time of a hashmap is **O(1)**.

### Algorithm
1. Create a hash map to store the value and index of each element in the array.
2. Iterate through the array and compute the complement of the current element, which is target - nums[i].
3. Check if the complement exists in the hash map.
4. If it does, return the indices of the current element and its complement.
5. If no such pair is found, return an empty array.

Also, `indices[diff] != i `makes sure we don’t pair an element with itself. Since the map was built first pass (value -> index), if `target == 2 * n` and there’s only one `n`, then diff equals `n` and `indices[diff]` would equal the current `i`. The check skips that, and only returns when the complement is at a different index (e.g., the second 3 in `[3,3]`, not the same one).